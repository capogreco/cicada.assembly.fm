<!DOCTYPE html>
<html>
<head>
    <title>Controller - Minimal Distributed Synth</title>
    <meta charset="utf-8">
    <style>
        :root {
            --cicada-green: #7FB069;
            --jungle-orange: #F4A261;
            --cream-white: #FDF6E3;
            --soft-green: #A8C686;
            --muted-orange: #E76F51;
            --warm-cream: #F2EAD3;
            --shadow: rgba(127, 176, 105, 0.15);
        }

        body {
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--cream-white) 0%, var(--warm-cream) 100%);
            color: #5A5A5A;
            font-size: 12px;
            line-height: 1.4;
            min-height: 100vh;
        }
        
        .main-container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            gap: 24px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px var(--shadow);
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
        }
        

        
        .controls-container {
            flex: 1;
            display: flex;
            flex-direction: row;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        @media (max-aspect-ratio: 1/1) {
            .controls-container {
                flex-direction: column;
            }
        }
        
        .sidebar {
            width: 240px;
            background: linear-gradient(145deg, var(--cicada-green), var(--soft-green));
            border-radius: 12px;
            padding: 20px;
            color: var(--cream-white);
            box-shadow: 0 4px 16px var(--shadow);
            flex-shrink: 0;
        }
        

        
        .slider-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            background: linear-gradient(145deg, rgba(244, 162, 97, 0.08), rgba(231, 111, 81, 0.08));
            border: 2px solid rgba(244, 162, 97, 0.3);
            border-radius: 12px;
            padding: 24px 16px 16px 16px;
            box-shadow: inset 0 2px 8px rgba(244, 162, 97, 0.1);
            position: relative;
            flex: 1;
            min-width: 0;
            width: 100%;
            max-width: 500px;
        }
        
        .system-controls {
            background: linear-gradient(145deg, var(--jungle-orange), var(--muted-orange));
            border-radius: 12px;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            color: var(--cream-white);
            box-shadow: 0 4px 16px rgba(244, 162, 97, 0.3);
        }
        
        .row-title {
            position: absolute;
            top: 8px;
            left: 16px;
            color: var(--muted-orange);
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: var(--cream-white);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(244, 162, 97, 0.3);
        }
        
        .sidebar h3 {
            margin: 0 0 16px 0;
            color: var(--cream-white);
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(253, 246, 227, 0.3);
            padding-bottom: 8px;
        }
        
        .control {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-width: 0;
            padding: 8px 4px;
            background: rgba(253, 246, 227, 0.15);
            border-radius: 8px;
            border: 1px solid rgba(127, 176, 105, 0.2);
            transition: all 0.2s ease;
            overflow: hidden;
        }
        
        .control:hover {
            background: rgba(253, 246, 227, 0.25);
            border-color: var(--cicada-green);
            transform: translateY(-1px);
        }
        
        .system-controls .control {
            min-width: auto;
            height: auto;
        }
        
        .control-label {
            color: #5A5A5A;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        
        .control-value {
            background: var(--cicada-green);
            color: var(--cream-white);
            font-size: 12px;
            font-weight: bold;
            padding: 3px 6px;
            border-radius: 4px;
            min-width: 40px;
            margin-bottom: 6px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        label {
            display: block;
            margin-bottom: 12px;
            color: #5A5A5A;
            font-size: 11px;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
            min-height: 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .system-controls label {
            color: var(--cream-white);
            font-weight: bold;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 90%;
            max-width: 80px;
            height: 5px;
            background: linear-gradient(90deg, rgba(127, 176, 105, 0.3), var(--cicada-green));
            border: none;
            border-radius: 3px;
            outline: none;
            margin: 8px 0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, var(--cicada-green), var(--soft-green));
            border-radius: 9px;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(127, 176, 105, 0.4);
            border: 3px solid var(--cream-white);
            transition: all 0.1s ease;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, var(--cicada-green), var(--soft-green));
            border-radius: 9px;
            cursor: pointer;
            border: 3px solid var(--cream-white);
            box-shadow: 0 3px 8px rgba(127, 176, 105, 0.4);
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
            accent-color: var(--cream-white);
            transform: scale(1.2);
        }
        
        button {
            background: linear-gradient(145deg, rgba(253, 246, 227, 0.9), var(--warm-cream));
            color: #5A5A5A;
            border: 2px solid rgba(127, 176, 105, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 9px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background: linear-gradient(145deg, var(--cicada-green), var(--soft-green));
            color: var(--cream-white);
            border-color: var(--cream-white);
            box-shadow: 0 4px 12px var(--shadow);
            transform: translateY(-1px);
        }
        
        .sin-inputs {
            display: flex;
            flex-direction: row;
            gap: 2px;
            margin-top: 4px;
            font-size: 7px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .sin-inputs > div {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .sin-inputs input {
            background: rgba(253, 246, 227, 0.9);
            color: #5A5A5A;
            border: 1px solid rgba(127, 176, 105, 0.5);
            border-radius: 3px;
            padding: 2px 3px;
            width: 24px;
            font-size: 7px;
            font-family: inherit;
            text-align: center;
        }
        
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .preset-buttons button {
            font-size: 9px;
            padding: 8px 12px;
            min-width: 80px;
        }
        
        #status {
            padding: 12px;
            background: rgba(253, 246, 227, 0.2);
            border: 2px solid rgba(253, 246, 227, 0.3);
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 10px;
            font-weight: bold;
        }
        
        .stats {
            background: rgba(253, 246, 227, 0.2);
            border: 2px solid rgba(253, 246, 227, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            font-size: 10px;
        }
        
        #synth_list {
            font-size: 10px;
        }
        
        .synth {
            padding: 8px;
            margin: 6px 0;
            background: rgba(253, 246, 227, 0.2);
            border: 1px solid rgba(253, 246, 227, 0.3);
            border-radius: 6px;
            font-size: 9px;
        }
        
        .latency {
            float: right;
            color: rgba(253, 246, 227, 0.7);
        }
        
        .audio-off {
            color: var(--muted-orange);
            font-weight: bold;
        }
        
        h4 {
            display: none;
        }
        
        /* VHS-inspired grain effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(127, 176, 105, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(244, 162, 97, 0.05) 0%, transparent 50%),
                linear-gradient(45deg, transparent 48%, rgba(253, 246, 227, 0.02) 49%, rgba(253, 246, 227, 0.02) 51%, transparent 52%);
            pointer-events: none;
            z-index: -1;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="controls-container">
    
            <div class="system-controls">
                <div class="control">
                    <label><input type="checkbox" id="power" checked> Power</label>
                </div>
                <div class="control">
                    <button id="regenerate_ratios">Regenerate Ratios</button>
                </div>
                <div class="preset-buttons">
                    <button id="preset_greengrocer">Greengrocer</button>
                    <button id="preset_double_drummer">Double Drummer</button>
                    <button id="preset_typewriter">Typewriter</button>
                    <button id="preset_redeye">Redeye</button>
                    <button id="preset_cherry_nose">Cherry Nose</button>
                </div>
            </div>
    
            <div class="slider-row">
                <span class="row-title">Click Generation & Filters</span>
                <div class="control">
                    <div class="control-label">Rate</div>
                    <div class="control-value" id="click_rate_value">200</div>
                    <input type="range" id="click_rate" min="50" max="800" step="5" value="200">
                    <div class="sin-inputs">
                        <div>N:<input type="text" id="click_rate_num_sin" value="1"></div>
                        <div>D:<input type="text" id="click_rate_den_sin" value="1"></div>
                    </div>
                </div>
                <div class="control">
                    <div class="control-label">Duration</div>
                    <div class="control-value" id="click_duration_value">3.0</div>
                    <input type="range" id="click_duration" min="0.01" max="10" step="0.01" value="3.0">
                </div>
                <div class="control">
                    <div class="control-label">Jitter</div>
                    <div class="control-value" id="click_jitter_value">0.1</div>
                    <input type="range" id="click_jitter" min="0" max="0.3" step="0.01" value="0.1">
                </div>
                <div class="control">
                    <div class="control-label">Noise</div>
                    <div class="control-value" id="noise_amount_value">0.7</div>
                    <input type="range" id="noise_amount" min="0" max="1" step="0.01" value="0.7">
                </div>
                <div class="control">
                    <div class="control-label">Primary Freq</div>
                    <div class="control-value" id="resonant_freq_value">800</div>
                    <input type="range" id="resonant_freq" min="200" max="3000" step="10" value="800">
                    <div class="sin-inputs">
                        <div>N:<input type="text" id="resonant_freq_num_sin" value="1"></div>
                        <div>D:<input type="text" id="resonant_freq_den_sin" value="1"></div>
                    </div>
                </div>
                <div class="control">
                    <div class="control-label">Primary Q</div>
                    <div class="control-value" id="resonant_q_value">8</div>
                    <input type="range" id="resonant_q" min="1" max="30" step="0.5" value="8">
                </div>
                <div class="control">
                    <div class="control-label">Harmonic Freq</div>
                    <div class="control-value" id="harmonic_freq_value">1600</div>
                    <input type="range" id="harmonic_freq" min="400" max="6000" step="10" value="1600">
                    <div class="sin-inputs">
                        <div>N:<input type="text" id="harmonic_freq_num_sin" value="1"></div>
                        <div>D:<input type="text" id="harmonic_freq_den_sin" value="1"></div>
                    </div>
                </div>
                <div class="control">
                    <div class="control-label">Harmonic Q</div>
                    <div class="control-value" id="harmonic_q_value">5</div>
                    <input type="range" id="harmonic_q" min="1" max="20" step="0.5" value="5">
                </div>
                <div class="control">
                    <div class="control-label">Volume</div>
                    <div class="control-value" id="cicada_amplitude_value">0.0</div>
                    <input type="range" id="cicada_amplitude" min="0" max="1" step="0.01" value="0.0">
                </div>
            </div>
    
            <div class="slider-row">
                <span class="row-title">Rhythm & Echeme Patterns</span>
                <div class="control">
                    <div class="control-label">Group Size</div>
                    <div class="control-value" id="pulse_group_size_value">6</div>
                    <input type="range" id="pulse_group_size" min="2" max="12" step="1" value="6">
                </div>
                <div class="control">
                    <div class="control-label">Sub Group</div>
                    <div class="control-value" id="sub_group_size_value">3</div>
                    <input type="range" id="sub_group_size" min="2" max="6" step="1" value="3">
                </div>
                <div class="control">
                    <div class="control-label">Group Space</div>
                    <div class="control-value" id="group_spacing_value">20</div>
                    <input type="range" id="group_spacing" min="5" max="100" step="1" value="20">
                    <div class="sin-inputs">
                        <div>N:<input type="text" id="group_spacing_num_sin" value="1"></div>
                        <div>D:<input type="text" id="group_spacing_den_sin" value="1"></div>
                    </div>
                </div>
                <div class="control">
                    <div class="control-label">Echo Rate</div>
                    <div class="control-value" id="echeme_rate_value">2.0</div>
                    <input type="range" id="echeme_rate" min="0" max="10" step="0.1" value="2.0">
                    <div class="sin-inputs">
                        <div>N:<input type="text" id="echeme_rate_num_sin" value="1"></div>
                        <div>D:<input type="text" id="echeme_rate_den_sin" value="1"></div>
                    </div>
                </div>
                <div class="control">
                    <div class="control-label">Echo Duration</div>
                    <div class="control-value" id="echeme_duration_value">300</div>
                    <input type="range" id="echeme_duration" min="50" max="2000" step="10" value="300">
                    <div class="sin-inputs">
                        <div>N:<input type="text" id="echeme_duration_num_sin" value="1"></div>
                        <div>D:<input type="text" id="echeme_duration_den_sin" value="1"></div>
                    </div>
                </div>
                <div class="control">
                    <div class="control-label">Duration Detune</div>
                    <div class="control-value" id="echeme_duration_detune_value">0</div>
                    <input type="range" id="echeme_duration_detune" min="0" max="2" step="0.1" value="0">
                </div>
                <div class="control">
                    <div class="control-label">Echo Spacing</div>
                    <div class="control-value" id="echeme_spacing_value">200</div>
                    <input type="range" id="echeme_spacing" min="50" max="1000" step="10" value="200">
                    <div class="sin-inputs">
                        <div>N:<input type="text" id="echeme_spacing_num_sin" value="1"></div>
                        <div>D:<input type="text" id="echeme_spacing_den_sin" value="1"></div>
                    </div>
                </div>
                <div class="control">
                    <div class="control-label">Spacing Detune</div>
                    <div class="control-value" id="echeme_spacing_detune_value">0</div>
                    <input type="range" id="echeme_spacing_detune" min="0" max="2" step="0.1" value="0">
                </div>
                <div class="control">
                    <div class="control-label">Intensity</div>
                    <div class="control-value" id="phrase_intensity_value">1.0</div>
                    <input type="range" id="phrase_intensity" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
        
        <!-- Hidden base value inputs for stochastic calculations -->
        <input type="hidden" id="click_rate_base" value="200">
        <input type="hidden" id="resonant_freq_base" value="800">
        <input type="hidden" id="harmonic_freq_base" value="1600">
        <input type="hidden" id="group_spacing_base" value="20">
        <input type="hidden" id="echeme_rate_base" value="2.0">
        <input type="hidden" id="echeme_duration_base" value="300">
        <input type="hidden" id="echeme_spacing_base" value="200">
        
        <div class="sidebar">
</edits>
            <h3>Cicada Controller</h3>
            <div id="status">Disconnected</div>
            
            <div class="stats">
                Connected: <strong id="connected_count">0</strong><br>
                Latency: <strong id="avg_latency">-</strong>
            </div>
            
            <div id="controller_warning" style="display: none; padding: 4px; background: #331100; border: 1px solid #ff6600; border-radius: 2px; margin-bottom: 8px; font-size: 9px;">
                ⚠️ Multiple controllers detected
                <div id="other_controllers" style="margin-top: 2px;"></div>
            </div>
            
            <h3>Connected Synths</h3>
            <div id="synth_list">None connected</div>
        </div>
    </div>

    <script type="module">
        import { PARAM_CONFIG, ParameterManager } from './parameter_definitions.js';
        import { StochasticDistributor } from './stochastic_distributor.js';
        
        const controller_id = `ctrl-${Math.random ().toString (36).substr (2, 9)}`
        const peers = new Map ()
        const other_controllers = new Set ()
        let ws = null
        let heartbeat_interval = null
        let wake_lock = null
        
        // webrtc configuration
        let rtc_config = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        }
        
        // fetch ice servers from server
        async function fetch_ice_servers () {
            try {
                const response = await fetch ("/ice-servers")
                const data = await response.json ()
                rtc_config.iceServers = data.ice_servers
                console.log ("ICE servers loaded:", rtc_config.iceServers)
            } catch (error) {
                console.error ("Failed to fetch ICE servers, using defaults:", error)
            }
        }
        
        // ui elements
        const status_el = document.getElementById ("status")
        const synth_list_el = document.getElementById ("synth_list")
        
        // harmonic ratio generator (always enabled)
        

        
        // dual-stage cicada synthesis controls
        const click_rate_el = document.getElementById ("click_rate")
        const click_rate_value_el = document.getElementById ("click_rate_value")
        const click_duration_el = document.getElementById ("click_duration")
        const click_duration_value_el = document.getElementById ("click_duration_value")
        const click_jitter_el = document.getElementById ("click_jitter")
        const click_jitter_value_el = document.getElementById ("click_jitter_value")
        const noise_amount_el = document.getElementById ("noise_amount")
        const noise_amount_value_el = document.getElementById ("noise_amount_value")
        const resonant_freq_el = document.getElementById ("resonant_freq")
        const resonant_freq_value_el = document.getElementById ("resonant_freq_value")
        const resonant_q_el = document.getElementById ("resonant_q")
        const resonant_q_value_el = document.getElementById ("resonant_q_value")
        const harmonic_freq_el = document.getElementById ("harmonic_freq")
        const harmonic_freq_value_el = document.getElementById ("harmonic_freq_value")
        const harmonic_q_el = document.getElementById ("harmonic_q")
        const harmonic_q_value_el = document.getElementById ("harmonic_q_value")
        const pulse_group_size_el = document.getElementById ("pulse_group_size")
        const pulse_group_size_value_el = document.getElementById ("pulse_group_size_value")
        const sub_group_size_el = document.getElementById ("sub_group_size")
        const sub_group_size_value_el = document.getElementById ("sub_group_size_value")
        const group_spacing_el = document.getElementById ("group_spacing")
        const group_spacing_value_el = document.getElementById ("group_spacing_value")
        const echeme_rate_el = document.getElementById ("echeme_rate")
        const echeme_rate_value_el = document.getElementById ("echeme_rate_value")
        const echeme_duration_el = document.getElementById ("echeme_duration")
        const echeme_duration_value_el = document.getElementById ("echeme_duration_value")
        const echeme_spacing_el = document.getElementById ("echeme_spacing")
        const echeme_spacing_value_el = document.getElementById ("echeme_spacing_value")
        const echeme_duration_detune_el = document.getElementById ("echeme_duration_detune")
        const echeme_duration_detune_value_el = document.getElementById ("echeme_duration_detune_value")
        const echeme_spacing_detune_el = document.getElementById ("echeme_spacing_detune")
        const echeme_spacing_detune_value_el = document.getElementById ("echeme_spacing_detune_value")
        const phrase_intensity_el = document.getElementById ("phrase_intensity")
        const phrase_intensity_value_el = document.getElementById ("phrase_intensity_value")
        const cicada_amplitude_el = document.getElementById ("cicada_amplitude")
        const cicada_amplitude_value_el = document.getElementById ("cicada_amplitude_value")
        
        // Debug: Check if all slider elements exist
        const sliderElements = {
            click_rate_el, click_rate_value_el,
            click_duration_el, click_duration_value_el,
            click_jitter_el, click_jitter_value_el,
            noise_amount_el, noise_amount_value_el,
            resonant_freq_el, resonant_freq_value_el,
            resonant_q_el, resonant_q_value_el,
            harmonic_freq_el, harmonic_freq_value_el,
            harmonic_q_el, harmonic_q_value_el,
            pulse_group_size_el, pulse_group_size_value_el,
            sub_group_size_el, sub_group_size_value_el,
            group_spacing_el, group_spacing_value_el,
            echeme_rate_el, echeme_rate_value_el,
            echeme_duration_el, echeme_duration_value_el,
            echeme_spacing_el, echeme_spacing_value_el,
            echeme_duration_detune_el, echeme_duration_detune_value_el,
            echeme_spacing_detune_el, echeme_spacing_detune_value_el,
            phrase_intensity_el, phrase_intensity_value_el,
            cicada_amplitude_el, cicada_amplitude_value_el
        };
        
        Object.entries(sliderElements).forEach(([name, element]) => {
            if (!element) {
                console.error(`SLIDER DEBUG: Missing element: ${name}`);
            } else {
                console.log(`SLIDER DEBUG: Found element: ${name}`);
            }
        });
        
        // species preset buttons
        const preset_greengrocer_btn = document.getElementById ("preset_greengrocer")
        const preset_double_drummer_btn = document.getElementById ("preset_double_drummer")
        const preset_typewriter_btn = document.getElementById ("preset_typewriter")
        const preset_redeye_btn = document.getElementById ("preset_redeye")
        const preset_cherry_nose_btn = document.getElementById ("preset_cherry_nose")

        // Controller state caching
        const CTRL_STATE_KEY = 'cicada_ctrl_state'
        
        function saveControllerState() {
            const state = {
                // Power and harmonic ratios
                power: power_el.checked,
                harmonic_ratios_enabled: true,
                
                // Main sliders
                click_rate: parseFloat(click_rate_el.value),
                click_duration: parseFloat(click_duration_el.value),
                click_jitter: parseFloat(click_jitter_el.value),
                noise_amount: parseFloat(noise_amount_el.value),
                resonant_freq: parseFloat(resonant_freq_el.value),
                resonant_q: parseFloat(resonant_q_el.value),
                harmonic_freq: parseFloat(harmonic_freq_el.value),
                harmonic_q: parseFloat(harmonic_q_el.value),
                pulse_group_size: parseInt(pulse_group_size_el.value),
                sub_group_size: parseInt(sub_group_size_el.value),
                group_spacing: parseFloat(group_spacing_el.value),
                echeme_rate: parseFloat(echeme_rate_el.value),
                echeme_duration: parseFloat(echeme_duration_el.value),
                echeme_spacing: parseFloat(echeme_spacing_el.value),
                echeme_duration_detune: parseFloat(echeme_duration_detune_el.value),
                echeme_spacing_detune: parseFloat(echeme_spacing_detune_el.value),
                phrase_intensity: parseFloat(phrase_intensity_el.value),
                cicada_amplitude: parseFloat(cicada_amplitude_el.value),
                
                // Base values for stochastic parameters
                click_rate_base: parseFloat(document.getElementById("click_rate_base").value),
                resonant_freq_base: parseFloat(document.getElementById("resonant_freq_base").value),
                harmonic_freq_base: parseFloat(document.getElementById("harmonic_freq_base").value),
                group_spacing_base: parseFloat(document.getElementById("group_spacing_base").value),
                echeme_rate_base: parseFloat(document.getElementById("echeme_rate_base").value),
                
                // SIN notation values
                click_rate_num_sin: document.getElementById("click_rate_num_sin").value,
                click_rate_den_sin: document.getElementById("click_rate_den_sin").value,
                resonant_freq_num_sin: document.getElementById("resonant_freq_num_sin").value,
                resonant_freq_den_sin: document.getElementById("resonant_freq_den_sin").value,
                harmonic_freq_num_sin: document.getElementById("harmonic_freq_num_sin").value,
                harmonic_freq_den_sin: document.getElementById("harmonic_freq_den_sin").value,
                group_spacing_num_sin: document.getElementById("group_spacing_num_sin").value,
                group_spacing_den_sin: document.getElementById("group_spacing_den_sin").value,
                echeme_rate_num_sin: document.getElementById("echeme_rate_num_sin").value,
                echeme_rate_den_sin: document.getElementById("echeme_rate_den_sin").value,
                
                timestamp: Date.now()
            };
            
            try {
                localStorage.setItem(CTRL_STATE_KEY, JSON.stringify(state));
                console.log("Controller state saved");
            } catch (e) {
                console.warn("Failed to save controller state:", e);
            }
        }
        
        function loadControllerState() {
            try {
                const saved = localStorage.getItem(CTRL_STATE_KEY);
                if (!saved) return false;
                
                const state = JSON.parse(saved);
                console.log("Loading controller state from cache");
                
                // Apply power and harmonic ratios
                power_el.checked = state.power !== undefined ? state.power : true;
                
                // Apply main sliders
                if (state.click_rate !== undefined) {
                    click_rate_el.value = state.click_rate;
                    click_rate_value_el.textContent = state.click_rate;
                }
                if (state.click_duration !== undefined) {
                    click_duration_el.value = state.click_duration;
                    click_duration_value_el.textContent = state.click_duration.toFixed(2);
                }
                if (state.click_jitter !== undefined) {
                    click_jitter_el.value = state.click_jitter;
                    click_jitter_value_el.textContent = state.click_jitter.toFixed(2);
                }
                if (state.noise_amount !== undefined) {
                    noise_amount_el.value = state.noise_amount;
                    noise_amount_value_el.textContent = state.noise_amount.toFixed(2);
                }
                if (state.resonant_freq !== undefined) {
                    resonant_freq_el.value = state.resonant_freq;
                    resonant_freq_value_el.textContent = Math.round(state.resonant_freq);
                }
                if (state.resonant_q !== undefined) {
                    resonant_q_el.value = state.resonant_q;
                    resonant_q_value_el.textContent = state.resonant_q;
                }
                if (state.harmonic_freq !== undefined) {
                    harmonic_freq_el.value = state.harmonic_freq;
                    harmonic_freq_value_el.textContent = Math.round(state.harmonic_freq);
                }
                if (state.harmonic_q !== undefined) {
                    harmonic_q_el.value = state.harmonic_q;
                    harmonic_q_value_el.textContent = state.harmonic_q;
                }
                if (state.pulse_group_size !== undefined) {
                    pulse_group_size_el.value = state.pulse_group_size;
                    pulse_group_size_value_el.textContent = state.pulse_group_size;
                }
                if (state.sub_group_size !== undefined) {
                    sub_group_size_el.value = state.sub_group_size;
                    sub_group_size_value_el.textContent = state.sub_group_size;
                }
                if (state.group_spacing !== undefined) {
                    group_spacing_el.value = state.group_spacing;
                    group_spacing_value_el.textContent = state.group_spacing;
                }
                if (state.echeme_rate !== undefined) {
                    echeme_rate_el.value = state.echeme_rate;
                    echeme_rate_value_el.textContent = state.echeme_rate.toFixed(1);
                }
                if (state.echeme_duration !== undefined) {
                    echeme_duration_el.value = state.echeme_duration;
                    echeme_duration_value_el.textContent = Math.round(state.echeme_duration);
                }
                if (state.echeme_spacing !== undefined) {
                    echeme_spacing_el.value = state.echeme_spacing;
                    echeme_spacing_value_el.textContent = Math.round(state.echeme_spacing);
                }
                if (state.echeme_duration_detune !== undefined) {
                    echeme_duration_detune_el.value = state.echeme_duration_detune;
                    echeme_duration_detune_value_el.textContent = state.echeme_duration_detune.toFixed(1);
                }
                if (state.echeme_spacing_detune !== undefined) {
                    echeme_spacing_detune_el.value = state.echeme_spacing_detune;
                    echeme_spacing_detune_value_el.textContent = state.echeme_spacing_detune.toFixed(1);
                }
                if (state.phrase_intensity !== undefined) {
                    phrase_intensity_el.value = state.phrase_intensity;
                    phrase_intensity_value_el.textContent = state.phrase_intensity.toFixed(1);
                }
                if (state.cicada_amplitude !== undefined) {
                    cicada_amplitude_el.value = state.cicada_amplitude;
                    cicada_amplitude_value_el.textContent = state.cicada_amplitude.toFixed(2);
                }
                
                // Apply base values
                if (state.click_rate_base !== undefined) {
                    document.getElementById("click_rate_base").value = state.click_rate_base;
                }
                if (state.resonant_freq_base !== undefined) {
                    document.getElementById("resonant_freq_base").value = state.resonant_freq_base;
                }
                if (state.harmonic_freq_base !== undefined) {
                    document.getElementById("harmonic_freq_base").value = state.harmonic_freq_base;
                }
                if (state.group_spacing_base !== undefined) {
                    document.getElementById("group_spacing_base").value = state.group_spacing_base;
                }
                if (state.echeme_rate_base !== undefined) {
                    document.getElementById("echeme_rate_base").value = state.echeme_rate_base;
                }
                
                // Apply SIN notation values
                if (state.click_rate_num_sin !== undefined) {
                    document.getElementById("click_rate_num_sin").value = state.click_rate_num_sin;
                }
                if (state.click_rate_den_sin !== undefined) {
                    document.getElementById("click_rate_den_sin").value = state.click_rate_den_sin;
                }
                if (state.resonant_freq_num_sin !== undefined) {
                    document.getElementById("resonant_freq_num_sin").value = state.resonant_freq_num_sin;
                }
                if (state.resonant_freq_den_sin !== undefined) {
                    document.getElementById("resonant_freq_den_sin").value = state.resonant_freq_den_sin;
                }
                if (state.harmonic_freq_num_sin !== undefined) {
                    document.getElementById("harmonic_freq_num_sin").value = state.harmonic_freq_num_sin;
                }
                if (state.harmonic_freq_den_sin !== undefined) {
                    document.getElementById("harmonic_freq_den_sin").value = state.harmonic_freq_den_sin;
                }
                if (state.group_spacing_num_sin !== undefined) {
                    document.getElementById("group_spacing_num_sin").value = state.group_spacing_num_sin;
                }
                if (state.group_spacing_den_sin !== undefined) {
                    document.getElementById("group_spacing_den_sin").value = state.group_spacing_den_sin;
                }
                if (state.echeme_rate_num_sin !== undefined) {
                    document.getElementById("echeme_rate_num_sin").value = state.echeme_rate_num_sin;
                }
                if (state.echeme_rate_den_sin !== undefined) {
                    document.getElementById("echeme_rate_den_sin").value = state.echeme_rate_den_sin;
                }
                
                console.log("Controller state loaded successfully");
                return true;
            } catch (e) {
                console.warn("Failed to load controller state:", e);
                return false;
            }
        }
        
        // connect to websocket
        function connect_websocket () {
            const protocol = window.location.protocol === "https:" ? "wss:" : "ws:"
            ws = new WebSocket (`${protocol}//${window.location.host}/ws`)
            
            ws.addEventListener ("open", () => {
                console.log ("connected to server")
                status_el.textContent = `Connected as ${controller_id}`
                
                // register with server
                send_message ({
                    type: "register",
                    client_id: controller_id
                })
                
                // announce presence to other controllers (for warning system)
                send_message ({
                    type: "announce", 
                    source: controller_id,
                    target: "ctrl-*"
                })
                
                // start heartbeat interval
                heartbeat_interval = setInterval (() => {
                    send_message ({
                        type: "heartbeat",
                        source: controller_id
                    })
                    console.log ("sent heartbeat")
                }, 20000) // every 20 seconds
            })
            
            ws.addEventListener ("message", async (event) => {
                const message = JSON.parse (event.data)
                await handle_message (message)
            })
            
            ws.addEventListener ("close", () => {
                console.log ("disconnected from server")
                status_el.textContent = "Disconnected - Reconnecting..."
                
                // clear heartbeat interval
                if (heartbeat_interval) {
                    clearInterval (heartbeat_interval)
                    heartbeat_interval = null
                }
                
                setTimeout (connect_websocket, 2000)
            })
        }
        
        // send message via websocket
        function send_message (message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send (JSON.stringify (message))
            }
        }
        
        // handle incoming messages
        async function handle_message (message) {
            console.log ("received:", message)
            
            if (message.type === "announce" && message.source.startsWith ("ctrl-") && message.source !== controller_id) {
                // another controller announced itself
                const is_new = !other_controllers.has (message.source)
                other_controllers.add (message.source)
                update_controller_warning ()
                // announce back only if this is a new controller
                if (is_new) {
                    send_message ({
                        type: "announce",
                        source: controller_id,
                        target: message.source
                    })
                }
                
            } else if (message.type === "offer") {
                // handle webrtc offer from synth
                await handle_offer (message)
                
            } else if (message.type === "answer") {
                // handle webrtc answer from synth
                const peer = peers.get (message.source)
                if (peer && peer.connection) {
                    await peer.connection.setRemoteDescription (message.data)
                    
                    // process any queued ice candidates
                    if (peer.ice_queue.length > 0) {
                        console.log (`processing ${peer.ice_queue.length} queued ice candidates`)
                        for (const candidate of peer.ice_queue) {
                            await peer.connection.addIceCandidate (candidate)
                        }
                        peer.ice_queue = []
                    }
                }
                
            } else if (message.type === "ice") {
                // handle ice candidate
                const peer = peers.get (message.source)
                if (peer && peer.connection) {
                    try {
                        if (peer.connection.remoteDescription) {
                            console.log (`adding ice candidate: ${message.data.candidate}`)
                            await peer.connection.addIceCandidate (message.data)
                        } else {
                            // queue ice candidate until remote description is set
                            console.log ("queueing ice candidate")
                            peer.ice_queue.push (message.data)
                        }
                    } catch (error) {
                        console.error ("error adding ice candidate:", error)
                    }
                }
            }
        }
        

        
        // send touch data (placeholder for now - no touch handling implemented yet)
        function send_touch_data () {
            // TODO: implement touch/mouse position tracking and sending
            console.log ("send_touch_data called - not implemented yet")
        }
        
        // handle incoming offer from synth
        async function handle_offer (message) {
            console.log (`handling offer from ${message.source}`)
            
            const pc = new RTCPeerConnection (rtc_config)
            
            // store peer info
            const peer = {
                connection: pc,
                channel: null,
                ice_queue: [],
                latency: null,
                ping_interval: null,
                state: {
                    audio_enabled: false,
                    volume: 0.2,
                    powered_on: true
                }
            }
            peers.set (message.source, peer)
            
            // handle ice candidates
            pc.addEventListener ("icecandidate", (event) => {
                if (event.candidate) {
                    console.log (`sending ice candidate: ${event.candidate.candidate}`)
                    send_message ({
                        type: "ice",
                        source: controller_id,
                        target: message.source,
                        data: event.candidate
                    })
                } else {
                    console.log ("ice gathering complete")
                }
            })
            
            // handle data channels from synth (single channel approach)
            pc.addEventListener ("datachannel", (event) => {
                const channel = event.channel
                console.log (`received data channel: ${channel.label}`)
                
                if (channel.label === "main") {
                    peer.channel = channel
                    
                    channel.addEventListener ("open", () => {
                        console.log (`main channel open to ${message.source}`)
                        update_synth_list (message.source, "connected")
                        
                        // start ping interval
                        peer.ping_interval = setInterval (() => {
                            if (channel.readyState === "open") {
                                channel.send (JSON.stringify ({
                                    type: "ping",
                                    timestamp: Date.now ()
                                }))
                            }
                        }, 1000)
                        
                        // Initial state will be sent when synth requests it after audio initialization
                        console.log(`WebRTC connection ready to ${message.source} - waiting for parameter request`)
                    })
                    
                    channel.addEventListener ("message", (event) => {
                        const data = JSON.parse (event.data)
                        if (data.type === "pong") {
                            const rtt = Date.now () - data.timestamp
                            peer.latency = rtt
                            // update state if provided
                            if (data.state) {
                                peer.state = data.state
                            }
                            update_synth_list (message.source, pc.connectionState)
                        } else if (data.type === "request_initial_state") {
                            console.log(`Received initial state request from ${data.synth_id}`)
                            sendInitialStateToSynth(peer, data.synth_id)
                        }
                    })
                    
                    channel.addEventListener ("close", () => {
                        if (peer.ping_interval) {
                            clearInterval (peer.ping_interval)
                            peer.ping_interval = null
                        }
                    })
                }
            })
            
            // handle connection state
            pc.addEventListener ("connectionstatechange", () => {
                console.log (`connection state: ${pc.connectionState}`)
                update_synth_list (message.source, pc.connectionState)
                
                if (pc.connectionState === "failed" || pc.connectionState === "closed") {
                    // clean up disconnected peer
                    if (peer.ping_interval) {
                        clearInterval (peer.ping_interval)
                    }
                    peers.delete (message.source)
                    update_synth_list (message.source, "disconnected")
                }
            })
            
            // set remote description and create answer
            await pc.setRemoteDescription (message.data)
            const answer = await pc.createAnswer ()
            await pc.setLocalDescription (answer)
            
            // process any queued ice candidates
            if (peer.ice_queue.length > 0) {
                console.log (`processing ${peer.ice_queue.length} queued ice candidates`)
                for (const candidate of peer.ice_queue) {
                    await pc.addIceCandidate (candidate)
                }
                peer.ice_queue = []
            }
            
            // send answer back
            send_message ({
                type: "answer",
                source: controller_id,
                target: message.source,
                data: answer
            })
        }
        
        // COMMENTED OUT: Controllers now accept connections instead of initiating them
        /*
        // create webrtc connection to synth
        window.connect_to_synth = async function (synth_id) {
            console.log (`connecting to ${synth_id}`)
            
            const pc = new RTCPeerConnection (rtc_config)
            // create two channels - UDP-like for params, TCP-like for commands
            const param_channel = pc.createDataChannel ("params", { 
                ordered: false,
                maxRetransmits: 0 
            })
            const command_channel = pc.createDataChannel ("commands", { 
                ordered: true 
            })
            
            // store peer info
            peers.set (synth_id, {
                connection: pc,
                param_channel: param_channel,
                command_channel: command_channel,
                ice_queue: [],
                latency: null,
                ping_interval: null
            })
            
            // handle ice candidates
            pc.addEventListener ("icecandidate", (event) => {
                if (event.candidate) {
                    console.log (`sending ice candidate: ${event.candidate.candidate}`)
                    send_message ({
                        type: "ice",
                        source: controller_id,
                        target: synth_id,
                        data: event.candidate
                    })
                } else {
                    console.log ("ice gathering complete")
                }
            })
            
            // handle connection state
            pc.addEventListener ("connectionstatechange", () => {
                console.log (`connection state: ${pc.connectionState}`)
                
                if (pc.connectionState === "failed" || pc.connectionState === "closed") {
                    // clean up disconnected peer
                    const peer = peers.get (synth_id)
                    if (peer && peer.ping_interval) {
                        clearInterval (peer.ping_interval)
                    }
                    peers.delete (synth_id)
                    
                    // retry connection after a delay
                    if (pc.connectionState === "failed") {
                        console.log (`retrying connection to ${synth_id} in 3 seconds...`)
                        setTimeout (() => {
                            // check if synth is still announcing
                            send_message ({
                                type: "announce",
                                source: controller_id,
                                target: synth_id
                            })
                        }, 3000)
                    }
                }
                
                update_synth_list (synth_id, pc.connectionState)
            })
            
            // monitor ice connection state
            pc.addEventListener ("iceconnectionstatechange", () => {
                console.log (`ice connection state: ${pc.iceConnectionState}`)
            })
            
            // monitor ice gathering state
            pc.addEventListener ("icegatheringstatechange", () => {
                console.log (`ice gathering state: ${pc.iceGatheringState}`)
            })
            
            // handle param channel (UDP-like)
            param_channel.addEventListener ("open", () => {
                console.log (`param channel open to ${synth_id}`)
            })
                
                // start latency monitoring
                const peer = peers.get (synth_id)
                peer.ping_interval = setInterval (() => {
                    if (param_channel.readyState === "open") {
                        param_channel.send (JSON.stringify ({
                            type: "ping",
                            timestamp: Date.now ()
                        }))
                    }
                }, 1000)
            })
            
            // handle param channel messages
            param_channel.addEventListener ("message", (event) => {
                const data = JSON.parse (event.data)
                if (data.type === "pong") {
                    const rtt = Date.now () - data.timestamp
                    const peer = peers.get (synth_id)
                    peer.latency = rtt
                    update_synth_list (synth_id, pc.connectionState)
                }
            })
            
            // handle param channel close
            param_channel.addEventListener ("close", () => {
                const peer = peers.get (synth_id)
                if (peer.ping_interval) {
                    clearInterval (peer.ping_interval)
                }
            })
            
            // handle command channel (TCP-like)
            command_channel.addEventListener ("open", () => {
                console.log (`command channel open to ${synth_id}`)
                // send current power state
                const is_on = power_el.checked
                command_channel.send (JSON.stringify ({
                    type: "command",
                    name: "power",
                    value: is_on
                }))
            })
            
            // create and send offer
            const offer = await pc.createOffer ()
            await pc.setLocalDescription (offer)
            
            send_message ({
                type: "offer",
                source: controller_id,
                target: synth_id,
                data: offer
            })
        }
        */
        
        // update synth list ui
        function update_synth_list (synth_id, status) {
            if (status === "discovered" && !peers.has (synth_id)) {
                peers.set (synth_id, { 
                    connection: null, 
                    channel: null,
                    state: {
                        audio_enabled: false,
                        volume: 0.2,
                        powered_on: true
                    }
                })
            }
            
            const synth_entries = Array.from (peers.entries ())
            
            if (synth_entries.length === 0) {
                synth_list_el.innerHTML = "None connected"
            } else {
                synth_list_el.innerHTML = synth_entries.map (([id, peer]) => {
                    const state = peer.connection ? peer.connection.connectionState : "discovered"
                    const color = state === "connected" ? "#4a4" : 
                                 state === "connecting" ? "#aa4" : "#888"
                    const latency_text = peer.latency !== null ? `<span class="latency">${peer.latency}ms</span>` : ""
                    const audio_indicator = (peer.state && peer.state.audio_enabled) ? "" : " <span class='audio-off'>[audio off]</span>"
                    return `<div class="synth" style="color: ${color};">${id} [${state}]${audio_indicator} ${latency_text}</div>`
                }).join ("")
            }
            
            // update stats
            update_stats ()
        }
        
        // update connection stats
        function update_stats () {
            const connected_peers = Array.from (peers.values ()).filter (
                peer => peer.connection && peer.connection.connectionState === "connected"
            )
            
            document.getElementById ("connected_count").textContent = connected_peers.length
            
            const latencies = connected_peers
                .map (peer => peer.latency)
                .filter (latency => latency !== null)
            
            if (latencies.length > 0) {
                const avg = Math.round (latencies.reduce ((a, b) => a + b, 0) / latencies.length)
                document.getElementById ("avg_latency").textContent = `${avg}ms`
            } else {
                document.getElementById ("avg_latency").textContent = "-"
            }
        }
        

        
        // power on/off control
        const power_el = document.getElementById ("power")
        power_el.addEventListener ("change", (e) => {
            const value = e.target.checked ? 1 : 0
            handleParameterChange("powered_on", value)
            saveControllerState()
        })
        
        // harmonic ratio generator functions
        function parseSIN(notation) {
            if (notation.includes('-')) {
                const [start, end] = notation.split('-').map(Number);
                return Array.from({length: end - start + 1}, (_, i) => start + i);
            } else {
                return notation.split(',').map(Number);
            }
        }
        
        function generateHarmonicRatio(numSIN, denSIN) {
            const numerators = parseSIN(numSIN);
            const denominators = parseSIN(denSIN);
            const num = numerators[Math.floor(Math.random() * numerators.length)];
            const den = denominators[Math.floor(Math.random() * denominators.length)];
            return num / den;
        }
        

        

        
        function sendInitialStateToSynth(peer, synthId) {
            console.log(`DEBUG: sendInitialStateToSynth called for synth: ${synthId}`);
            
            if (!peer.channel || peer.channel.readyState !== "open") {
                console.log("Cannot send initial state - channel not ready");
                return;
            }
            
            console.log("Sending initial state to new synth");
            
            // Send current parameter values using unified pipeline
            Object.keys(PARAM_CONFIG).forEach(paramName => {
                const config = PARAM_CONFIG[paramName];
                const rawValue = ParameterManager.getElementValue(config.element);
                
                // Debug logging for power state
                if (paramName === "powered_on") {
                    console.log(`DEBUG: Power state - element: ${config.element}, rawValue: ${rawValue}, checkbox checked: ${document.getElementById(config.element).checked}`);
                }
                
                if (rawValue !== null) {
                    distributeParameter(paramName, rawValue, config, synthId);
                    
                    // Debug logging for power state distribution
                    if (paramName === "powered_on") {
                        console.log(`DEBUG: Distributed power state - paramName: ${paramName}, rawValue: ${rawValue}, to synth: ${synthId}`);
                    }
                }
            });
            
            console.log(`Sent initial state to ${synthId}`);
        }
        
        function regenerateHarmonicRatios() {
            console.log("Regenerating harmonic ratios for all stochastic parameters");
            
            // Re-send all stochastic parameters to force regeneration
            ParameterManager.getStochasticParams().forEach(paramName => {
                const config = PARAM_CONFIG[paramName];
                const rawValue = ParameterManager.getElementValue(config.element);
                if (rawValue !== null) {
                    handleParameterChange(paramName, rawValue, true); // force regeneration
                }
            });
            
            console.log("Harmonic ratios regenerated");
        }
        
        // Unified parameter handling pipeline
        function handleParameterChange(paramName, rawValue, forceRegeneration = false) {
            console.log(`DEBUG: handleParameterChange called with paramName: ${paramName}, rawValue: ${rawValue}`);
            const config = PARAM_CONFIG[paramName];
            if (!config) {
                console.warn(`Unknown parameter: ${paramName}`, 'Available params:', Object.keys(PARAM_CONFIG));
                return;
            }
            
            // Update base value for stochastic parameters
            if (config.stochastic) {
                document.getElementById(config.stochastic.baseElement).value = rawValue;
            }
            
            // Distribute to all connected synths
            peers.forEach((peer, synthId) => {
                if (peer.channel && peer.channel.readyState === "open") {
                    distributeParameter(paramName, rawValue, config, synthId, forceRegeneration);
                }
            });
        }
        
        function distributeParameter(paramName, rawValue, config, synthId, forceRegeneration = false) {
            // Apply unit conversion
            const baseValue = rawValue * config.unit;
            
            // Debug logging for power state
            if (paramName === "powered_on") {
                console.log(`DEBUG: distributeParameter - paramName: ${paramName}, rawValue: ${rawValue}, baseValue: ${baseValue}, config.unit: ${config.unit}`);
            }
            
            // Send to synth with unified message format
            const peer = peers.get(synthId);
            if (peer && peer.channel && peer.channel.readyState === "open") {
                const message = {
                    type: "param_update",
                    name: paramName,
                    value: baseValue,
                    rampTime: config.rampTime,
                    integer: config.integer || false,
                    boolean: config.boolean || false,
                    safety: config.safety
                };
                
                // Add stochastic info if this parameter supports it
                if (config.stochastic) {
                    const stochasticConfig = ParameterManager.getStochasticConfig();
                    message.stochastic = {
                        enabled: true,
                        config: stochasticConfig[paramName],
                        forceRegeneration: forceRegeneration
                    };
                } else {
                    message.stochastic = { enabled: false };
                }
                
                // Debug logging for complete power state message
                if (paramName === "powered_on") {
                    console.log(`DEBUG: Complete power message being sent:`, message);
                }
                
                peer.channel.send(JSON.stringify(message));
            }
        }
        
        // Unified event handlers using parameter pipeline
        click_rate_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: click_rate slider changed to ${value}`);
            document.getElementById("click_rate_base").value = value
            click_rate_value_el.textContent = value;
            console.log(`DEBUG: Updated click_rate display to: ${click_rate_value_el.textContent}`);
            handleParameterChange("clickRate", value)
            saveControllerState()
        })
        
        click_duration_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: click_duration slider changed to ${value}`);
            click_duration_value_el.textContent = value.toFixed(2);
            console.log(`DEBUG: Updated click_duration display to: ${click_duration_value_el.textContent}`);
            handleParameterChange("clickDuration", value)
            saveControllerState()
        })
        
        click_jitter_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: click_jitter slider changed to ${value}`);
            click_jitter_value_el.textContent = value.toFixed(2);
            handleParameterChange("clickJitter", value)
            saveControllerState()
        })
        
        noise_amount_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: noise_amount slider changed to ${value}`);
            noise_amount_value_el.textContent = value.toFixed(2);
            handleParameterChange("noiseAmount", value)
            saveControllerState()
        })
        
        resonant_freq_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: resonant_freq slider changed to ${value}`);
            document.getElementById("resonant_freq_base").value = value
            resonant_freq_value_el.textContent = Math.round(value);
            handleParameterChange("resonantFreq", value)
            saveControllerState()
        })
        
        resonant_q_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: resonant_q slider changed to ${value}`);
            resonant_q_value_el.textContent = value.toFixed(1);
            handleParameterChange("resonantQ", value)
            saveControllerState()
        })
        
        harmonic_freq_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: harmonic_freq slider changed to ${value}`);
            document.getElementById("harmonic_freq_base").value = value
            harmonic_freq_value_el.textContent = Math.round(value);
            handleParameterChange("harmonicFreq", value)
            saveControllerState()
        })
        
        harmonic_q_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: harmonic_q slider changed to ${value}`);
            harmonic_q_value_el.textContent = value.toFixed(1);
            handleParameterChange("harmonicQ", value)
            saveControllerState()
        })
        
        echeme_rate_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: echeme_rate slider changed to ${value}`);
            document.getElementById("echeme_rate_base").value = value
            echeme_rate_value_el.textContent = value.toFixed(1);
            handleParameterChange("echemeRate", value)
            saveControllerState()
        })
        
        echeme_duration_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: echeme_duration slider changed to ${value}`);
            document.getElementById("echeme_duration_base").value = value
            echeme_duration_value_el.textContent = Math.round(value);
            handleParameterChange("echemeDuration", value)
            saveControllerState()
        })
        
        echeme_spacing_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: echeme_spacing slider changed to ${value}`);
            document.getElementById("echeme_spacing_base").value = value
            echeme_spacing_value_el.textContent = Math.round(value);
            handleParameterChange("echemeSpacing", value)
            saveControllerState()
        })
        
        echeme_duration_detune_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: echeme_duration_detune slider changed to ${value}`);
            echeme_duration_detune_value_el.textContent = value.toFixed(1);
            handleParameterChange("echemeDurationDetune", value)
            saveControllerState()
        })
        
        echeme_spacing_detune_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: echeme_spacing_detune slider changed to ${value}`);
            echeme_spacing_detune_value_el.textContent = value.toFixed(1);
            handleParameterChange("echemeSpacingDetune", value)
            saveControllerState()
        })
        
        phrase_intensity_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: phrase_intensity slider changed to ${value}`);
            phrase_intensity_value_el.textContent = value.toFixed(1);
            handleParameterChange("phraseIntensity", value)
            saveControllerState()
        })
        
        cicada_amplitude_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: cicada_amplitude slider changed to ${value}`);
            cicada_amplitude_value_el.textContent = value.toFixed(2);
            handleParameterChange("amplitude", value)
            saveControllerState()
        })
        
        // Former discrete parameters (now unified)
        pulse_group_size_el.addEventListener ("input", (e) => {
            const value = parseInt (e.target.value)
            console.log(`DEBUG: pulse_group_size slider changed to ${value}`);
            pulse_group_size_value_el.textContent = value;
            handleParameterChange("pulseGroupSize", value)
            saveControllerState()
        })
        
        sub_group_size_el.addEventListener ("input", (e) => {
            const value = parseInt (e.target.value)
            console.log(`DEBUG: sub_group_size slider changed to ${value}`);
            sub_group_size_value_el.textContent = value;
            console.log(`DEBUG: Updated sub_group_size display to: ${sub_group_size_value_el.textContent}`);
            console.log(`DEBUG: sub_group_size_value_el element:`, sub_group_size_value_el);
            handleParameterChange("subGroupSize", value)
            saveControllerState()
        })
        
        group_spacing_el.addEventListener ("input", (e) => {
            const value = parseFloat (e.target.value)
            console.log(`DEBUG: group_spacing slider changed to ${value}`);
            document.getElementById("group_spacing_base").value = value
            group_spacing_value_el.textContent = Math.round(value);
            console.log(`DEBUG: Updated group_spacing display to: ${group_spacing_value_el.textContent}`);
            handleParameterChange("groupSpacing", value)
            saveControllerState()
        })
        
        // regenerate ratios button
        document.getElementById("regenerate_ratios").addEventListener("click", regenerateHarmonicRatios)
        
        // SIN field change listeners (regenerate on notation changes)
        document.getElementById("click_rate_num_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("click_rate_den_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("resonant_freq_num_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("resonant_freq_den_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("harmonic_freq_num_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("harmonic_freq_den_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("group_spacing_num_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("group_spacing_den_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("echeme_rate_num_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        document.getElementById("echeme_rate_den_sin").addEventListener("change", (e) => {
            regenerateHarmonicRatios()
            saveControllerState()
        })
        
        // Base value change listeners
        document.getElementById("click_rate_base").addEventListener("change", saveControllerState)
        document.getElementById("resonant_freq_base").addEventListener("change", saveControllerState)
        document.getElementById("harmonic_freq_base").addEventListener("change", saveControllerState)
        document.getElementById("group_spacing_base").addEventListener("change", saveControllerState)
        document.getElementById("echeme_rate_base").addEventListener("change", saveControllerState)
        
        // Harmonic ratios always enabled (no toggle)

        // initialize UI to default values (override browser memory)
        power_el.checked = true
        
        // initialize dual-stage controls to defaults
        click_rate_el.value = 200
        click_rate_value_el.textContent = "200"
        click_duration_el.value = 3.0
        click_duration_value_el.textContent = "3.0"
        click_jitter_el.value = 0.1
        click_jitter_value_el.textContent = "0.10"
        noise_amount_el.value = 0.7
        noise_amount_value_el.textContent = "0.70"
        resonant_freq_el.value = 800
        resonant_freq_value_el.textContent = "800"
        resonant_q_el.value = 8
        resonant_q_value_el.textContent = "8.0"
        harmonic_freq_el.value = 1600
        harmonic_freq_value_el.textContent = "1600"
        harmonic_q_el.value = 5
        harmonic_q_value_el.textContent = "5.0"
        pulse_group_size_el.value = 6
        pulse_group_size_value_el.textContent = "6"
        sub_group_size_el.value = 3
        sub_group_size_value_el.textContent = "3"
        group_spacing_el.value = 20
        group_spacing_value_el.textContent = "20"
        echeme_rate_el.value = 2.0
        echeme_rate_value_el.textContent = "2.0"
        echeme_duration_el.value = 300
        echeme_duration_value_el.textContent = "300"
        echeme_spacing_el.value = 200
        echeme_spacing_value_el.textContent = "200"
        phrase_intensity_el.value = 1.0
        phrase_intensity_value_el.textContent = "1.0"
        cicada_amplitude_el.value = 0.0
        cicada_amplitude_value_el.textContent = "0.00"
        
        // species preset functions with controller-side ramping
        function apply_preset(params) {
            const rampDuration = 3000; // 3 seconds in milliseconds
            const startTime = Date.now();
            const updateInterval = 50; // Send updates every 50ms
            
            // Store starting values
            const startValues = {
                clickRate: parseFloat(click_rate_el.value),
                clickDuration: parseFloat(click_duration_el.value),
                clickJitter: parseFloat(click_jitter_el.value),
                noiseAmount: parseFloat(noise_amount_el.value),
                resonantFreq: parseFloat(resonant_freq_el.value),
                resonantQ: parseFloat(resonant_q_el.value),
                harmonicFreq: parseFloat(harmonic_freq_el.value),
                harmonicQ: parseFloat(harmonic_q_el.value),
                echemeRate: parseFloat(echeme_rate_el.value),
                echemeDuration: parseFloat(echeme_duration_el.value),
                echemeSpacing: parseFloat(echeme_spacing_el.value),
                phraseIntensity: parseFloat(phrase_intensity_el.value),
                cicadaAmplitude: parseFloat(cicada_amplitude_el.value)
            };
            
            // Send discrete parameters immediately
            handleParameterChange("pulseGroupSize", params.pulseGroupSize);
            handleParameterChange("subGroupSize", params.subGroupSize);
            
            // Send continuous stochastic parameter
            handleParameterChange("groupSpacing", params.groupSpacing);
            
            // Update discrete parameter displays
            pulse_group_size_el.value = params.pulseGroupSize;
            pulse_group_size_value_el.textContent = params.pulseGroupSize;
            sub_group_size_el.value = params.subGroupSize;
            sub_group_size_value_el.textContent = params.subGroupSize;
            group_spacing_el.value = params.groupSpacing;
            group_spacing_value_el.textContent = params.groupSpacing;
            
            // Regenerate harmonic ratios for species preset
            regenerateHarmonicRatios();
            
            // Start ramping continuous parameters
            function rampParameters() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / rampDuration, 1.0);
                
                // Interpolate each continuous parameter
                const current = {
                    clickRate: startValues.clickRate + (params.clickRate - startValues.clickRate) * progress,
                    clickDuration: startValues.clickDuration + (params.clickDuration - startValues.clickDuration) * progress,
                    clickJitter: startValues.clickJitter + (params.clickJitter - startValues.clickJitter) * progress,
                    noiseAmount: startValues.noiseAmount + (params.noiseAmount - startValues.noiseAmount) * progress,
                    resonantFreq: startValues.resonantFreq + (params.resonantFreq - startValues.resonantFreq) * progress,
                    resonantQ: startValues.resonantQ + (params.resonantQ - startValues.resonantQ) * progress,
                    harmonicFreq: startValues.harmonicFreq + (params.harmonicFreq - startValues.harmonicFreq) * progress,
                    harmonicQ: startValues.harmonicQ + (params.harmonicQ - startValues.harmonicQ) * progress,
                    echemeRate: startValues.echemeRate + (params.echemeRate - startValues.echemeRate) * progress,
                    echemeDuration: startValues.echemeDuration + (params.echemeDuration - startValues.echemeDuration) * progress,
                    echemeSpacing: startValues.echemeSpacing + (params.echemeSpacing - startValues.echemeSpacing) * progress,
                    phraseIntensity: startValues.phraseIntensity + (params.phraseIntensity - startValues.phraseIntensity) * progress,
                    cicadaAmplitude: startValues.cicadaAmplitude + (params.cicadaAmplitude - startValues.cicadaAmplitude) * progress
                };
                
                // Update UI
                click_rate_el.value = current.clickRate;
                click_rate_value_el.textContent = Math.round(current.clickRate);
                click_duration_el.value = current.clickDuration;
                click_duration_value_el.textContent = current.clickDuration.toFixed(1);
                click_jitter_el.value = current.clickJitter;
                click_jitter_value_el.textContent = current.clickJitter.toFixed(2);
                noise_amount_el.value = current.noiseAmount;
                noise_amount_value_el.textContent = current.noiseAmount.toFixed(2);
                resonant_freq_el.value = current.resonantFreq;
                resonant_freq_value_el.textContent = Math.round(current.resonantFreq);
                resonant_q_el.value = current.resonantQ;
                resonant_q_value_el.textContent = current.resonantQ.toFixed(1);
                harmonic_freq_el.value = current.harmonicFreq;
                harmonic_freq_value_el.textContent = Math.round(current.harmonicFreq);
                harmonic_q_el.value = current.harmonicQ;
                harmonic_q_value_el.textContent = current.harmonicQ.toFixed(1);
                echeme_rate_el.value = current.echemeRate;
                echeme_rate_value_el.textContent = current.echemeRate.toFixed(1);
                echeme_duration_el.value = current.echemeDuration;
                echeme_duration_value_el.textContent = Math.round(current.echemeDuration);
                echeme_spacing_el.value = current.echemeSpacing;
                echeme_spacing_value_el.textContent = Math.round(current.echemeSpacing);
                phrase_intensity_el.value = current.phraseIntensity;
                phrase_intensity_value_el.textContent = current.phraseIntensity.toFixed(1);
                cicada_amplitude_el.value = current.cicadaAmplitude;
                cicada_amplitude_value_el.textContent = current.cicadaAmplitude.toFixed(2);
                
                // Send parameter updates to synths
                handleParameterChange("clickRate", current.clickRate);
                handleParameterChange("clickDuration", current.clickDuration);
                handleParameterChange("clickJitter", current.clickJitter);
                handleParameterChange("noiseAmount", current.noiseAmount);
                handleParameterChange("resonantFreq", current.resonantFreq);
                handleParameterChange("resonantQ", current.resonantQ);
                handleParameterChange("harmonicFreq", current.harmonicFreq);
                handleParameterChange("harmonicQ", current.harmonicQ);
                handleParameterChange("echemeRate", current.echemeRate);
                handleParameterChange("echemeDuration", current.echemeDuration);
                handleParameterChange("echemeSpacing", current.echemeSpacing);
                handleParameterChange("phraseIntensity", current.phraseIntensity);
                handleParameterChange("amplitude", current.cicadaAmplitude);
                
                // Continue ramping
                if (progress < 1.0) {
                    setTimeout(rampParameters, updateInterval);
                }
            }
            
            // Start the ramping process
            rampParameters();
        }
        
        // Species preset buttons
        preset_greengrocer_btn.addEventListener("click", () => {
            apply_preset({
                clickRate: 180,
                clickDuration: 4,
                clickJitter: 0.05,
                noiseAmount: 0.3,
                resonantFreq: 400,
                resonantQ: 6,
                harmonicFreq: 1200,
                harmonicQ: 4,
                pulseGroupSize: 8,
                subGroupSize: 4,
                groupSpacing: 15,
                echemeRate: 0,
                echemeDuration: 1000,
                echemeSpacing: 100,
                phraseIntensity: 1.0,
                cicadaAmplitude: 0.2
            });
        });
        
        preset_double_drummer_btn.addEventListener("click", () => {
            apply_preset({
                clickRate: 350,
                clickDuration: 2,
                clickJitter: 0.15,
                noiseAmount: 0.8,
                resonantFreq: 350,
                resonantQ: 12,
                harmonicFreq: 1050,
                harmonicQ: 8,
                pulseGroupSize: 8,
                subGroupSize: 3,
                groupSpacing: 30,
                echemeRate: 8,
                echemeDuration: 150,
                echemeSpacing: 75,
                phraseIntensity: 1.5,
                cicadaAmplitude: 0.4
            });
        });
        
        preset_typewriter_btn.addEventListener("click", () => {
            apply_preset({
                clickRate: 600,
                clickDuration: 1.5,
                clickJitter: 0.2,
                noiseAmount: 0.9,
                resonantFreq: 1200,
                resonantQ: 3,
                harmonicFreq: 2400,
                harmonicQ: 2,
                pulseGroupSize: 4,
                subGroupSize: 2,
                groupSpacing: 40,
                echemeRate: 15,
                echemeDuration: 80,
                echemeSpacing: 60,
                phraseIntensity: 0.8,
                cicadaAmplitude: 0.15
            });
        });
        
        preset_redeye_btn.addEventListener("click", () => {
            apply_preset({
                clickRate: 250,
                clickDuration: 3,
                clickJitter: 0.1,
                noiseAmount: 0.5,
                resonantFreq: 800,
                resonantQ: 8,
                harmonicFreq: 1600,
                harmonicQ: 5,
                pulseGroupSize: 6,
                subGroupSize: 3,
                groupSpacing: 25,
                echemeRate: 2,
                echemeDuration: 400,
                echemeSpacing: 300,
                phraseIntensity: 1.2,
                cicadaAmplitude: 0.25
            });
        });
        
        preset_cherry_nose_btn.addEventListener("click", () => {
            apply_preset({
                clickRate: 280,
                clickDuration: 2.5,
                clickJitter: 0.12,
                noiseAmount: 0.6,
                resonantFreq: 600,
                resonantQ: 10,
                harmonicFreq: 1800,
                harmonicQ: 6,
                pulseGroupSize: 7,
                subGroupSize: 3,
                groupSpacing: 22,
                echemeRate: 5,
                echemeDuration: 250,
                echemeSpacing: 150,
                phraseIntensity: 1.1,
                cicadaAmplitude: 0.18
            });
        });
        
        // Try to load saved state, otherwise use defaults
        if (!loadControllerState()) {
            console.log("No saved state found, using defaults");
            // initialize UI to default values (override browser memory)
            power_el.checked = true
        }
        
        // update controller warning display
        function update_controller_warning () {
            const warning_el = document.getElementById ("controller_warning")
            const list_el = document.getElementById ("other_controllers")
            
            if (other_controllers.size > 0) {
                warning_el.style.display = "block"
                list_el.textContent = `Other controllers: ${Array.from (other_controllers).join (", ")}`
            } else {
                warning_el.style.display = "none"
            }
        }
        
        // wake lock functions
        async function request_wake_lock () {
            try {
                if ('wakeLock' in navigator) {
                    wake_lock = await navigator.wakeLock.request('screen')
                    console.log('Wake lock acquired')
                    
                    wake_lock.addEventListener('release', () => {
                        console.log('Wake lock released')
                    })
                }
            } catch (err) {
                console.log(`Wake lock error: ${err.name}, ${err.message}`)
            }
        }
        
        async function handle_visibility_change () {
            if (document.visibilityState === 'visible') {
                // re-acquire wake lock when page becomes visible
                await request_wake_lock()
            }
        }
        
        // visibility change handler
        document.addEventListener('visibilitychange', handle_visibility_change)
        
        // start connection
        fetch_ice_servers ().then (() => {
            connect_websocket ()
            // request wake lock on startup
            request_wake_lock ()
        })
    </script>
</body>
</html>